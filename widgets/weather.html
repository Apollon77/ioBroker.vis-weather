<!--
    ioBroker.vis weather Widget-Set


    Copyright 10.2015-2019 René G. <info@rg-engineering.eu>
-->
<!-- here you can include so many css as you want -->
<!--<link rel="stylesheet" href="widgets/weather/css/style.css" />-->
<!--<link href="widgets/weather/css/flot.css" rel="stylesheet" type="text/css">-->

<script type="text/javascript" src="widgets/weather/lib/js/flot/jquery.flot.js"></script>
<script type="text/javascript" src="widgets/weather/lib/js/flot/jquery.flot.time.js"></script>
    

<!-- doku for flot : -->
<!--  https://github.com/flot/flot/blob/master/API.md -->

<style>
    .chart-placeholder {
        width: 100%;
        height: 100%;
        font-size: 14px;
        line-height: 1.2em;
    }
</style>

<script type="text/javascript">
    'use strict';

    //require('flot');

    var MarkingColor = "eaebe5";

    if (vis.editMode) {
        // Add words for basic widgets
        $.extend(true, systemDictionary, {
            //            "format_date": { "en": "Dateformat", "de": "Datumformat", "ru": "?????? ????" },
            //            "format_date_tooltip": {"en": "Dateformat","de": "Datumformat","ru": "?????? ????"},

            "weather": { "en": "weather", "de": "Wetter", "ru": "weather" },
            "1 second": { "en": "1 second", "de": "1 Sekunde", "ru": "1 ???????" },
            "10 seconds": { "en": "10 seconds", "de": "10 Sekunden", "ru": "10 ??????" },
            "30 seconds": { "en": "30 seconds", "de": "30 Sekunden", "ru": "30 ??????" },
            "1 minute": { "en": "1 minute", "de": "1 Minute", "ru": "1 ??????" },
            "2 minutes": { "en": "2 minutes", "de": "2 Minuten", "ru": "2 ??????" },
            "5 minutes": { "en": "5 minutes", "de": "5 Minuten", "ru": "5 ?????" },
            "10 minutes": { "en": "10 minutes", "de": "10 Minuten", "ru": "10 ?????" },
            "30 minutes": { "en": "30 minutes", "de": "30 Minuten", "ru": "30 ?????" },
            "1 hour": { "en": "1 hour", "de": "1 Stunde", "ru": "1 ???" },
            "2 hours": { "en": "2 hours", "de": "2 Stunden", "ru": "2 ????" },
            "4 hours": { "en": "4 hours", "de": "4 Stunden", "ru": "4 ????" },
            "8 hours": { "en": "8 hours", "de": "8 Stunden", "ru": "8 ?????" },
            "12 hours": { "en": "12 hours", "de": "12 Stunden", "ru": "12 ?????" },
            "24 hours": { "en": "24 hours", "de": "24 Stunden", "ru": "24 ????" },
            "instance": { "en": "weather instance", "de": "Wetterinstanz", "ru": "?????????" },
            "time_interval": { "en": "Time interval", "de": "Zeitintervall", "ru": "????????" },
            "group_rain": { "en": "rain", "de": "Regen", "ru": "???" },
            "group_temperature": { "en": "temperature", "de": "Temperatur", "ru": "???" },
            "group_clouds": { "en": "clouds", "de": "Wolken", "ru": "???" },
            "withxaxix": { "en": "show X axis", "de": "zeige X-Achse", "ru": "???" },
            "rainvisible": { "en": "rain visible", "de": "Regenmenge sichtbar", "ru": "???" },
            "rainchartType": { "en": "rain chart type", "de": "Regencharttype", "ru": "???" },
            "raincolor": { "en": "rain color", "de": "Farbe für Regenmenge", "ru": "???" },
            "chancerainvisible": { "en": "chance rain visible", "de": "Regenwahrscheinlichkeit sichtbar", "ru": "???" },
            "tempvisible": { "en": "visible", "de": "sichtbar", "ru": "???" },
            "tempchartType": { "en": "chart type", "de": "Charttype", "ru": "???" },
            "tempcolor": { "en": "color ", "de": "Farbe", "ru": "???" },
            "chanceraincolor": { "en": "chance rain color ", "de": "Farbe für Regenwahrscheinlichkeit", "ru": "???" },
            "cloudsvisible": { "en": "visible", "de": "sichtbar", "ru": "???" },
            "cloudschartType": { "en": "chart type", "de": "Charttype", "ru": "???" },
            "sunorcloud": { "en": "show sun or clouds", "de": "Anzeige Sonne oder Wolken", "ru": "???" },
            "cloudcolor": { "en": "color", "de": "Farbe", "ru": "???" },
            "line": { "en": "line", "de": "Linie", "ru": "???" },
            "bar": { "en": "bar", "de": "Balken", "ru": "???" },
            "sun": { "en": "sun", "de": "Sonne", "ru": "???" },
            "clouds": { "en": "clouds", "de": "Wolken", "ru": "???" },
            "axislabelcolor": { "en": "color axis label", "de": "Farbe Achsbeschriftung", "ru": "???" },
            "tickscolor": { "en": "color axis ticks", "de": "Farbe Achsmarke", "ru": "???" },
            "markingcolor": { "en": "color marking", "de": "Farbe Hervorhebung", "ru": "???" },
            "withmarking": { "en": "with marking", "de": "Hervorhebungen", "ru": "???" },
            "maxY_temp": { "en": "max value y-axix (0 for auto)", "de": "Max Wert Y-Achse (0 für auto)", "ru": "???" },
            "minY_temp": { "en": "min value y-axix (0 for auto)", "de": "Min Wert Y-Achse (0 für auto)", "ru": "???" },
            "yTempVisible": { "en": "show y axis", "de": "zeige Y-Achse", "ru": "???" },
            "yRainVisible": { "en": "show y axis for rain", "de": "zeige Y-Achse (Regenmenge)", "ru": "???" },
            "yCloudVisible": { "en": "show y axis", "de": "zeige Y-Achse", "ru": "???" },
            "yChanceRainVisible": { "en": "show y axis for chance rain", "de": "zeige Y-Achse (Regenwahrscheinlichkeit)", "ru": "???" },
            "xDateFormat": { "en": "format for date/time on x-axis", "de": "Datum-/Zeitformat X-Achse", "ru": "???" },
            "nobgcolor": { "en": "no background color", "de": "ohne Hintergrundfarbe", "ru": "nobgcolor" },
            "withborder": { "en": "show border", "de": "Rahmen anzeigen", "ru": "withborder" },
            "datastructure": { "en": "data structure", "de": "Datenstruktur", "ru": "data structure" },
        });
    }

    function SetMarkingColor(color) {
        MarkingColor=color;
    }

    function degreeFormatter(v, axis) {
        return v.toFixed(axis.tickDecimals) + "°C";
    }

    function percentageFormatter(v, axis) {
        return v.toFixed(axis.tickDecimals) + "%";
    }

    function mmFormatter(v, axis) {
        return v.toFixed(axis.tickDecimals) + "mm";
    }

    function GridMarkings(axes) {

        var markings = [];
        var minDate = new Date(axes.xaxis.min);

        const dayDiff = (axes.xaxis.max - axes.xaxis.min) / 1000 / 60 / 60 / 24;
        console.log('DayDiff ' + dayDiff);

        var i = minDate.getTime();

        //if we only few hours then we need markings per hour otherwise per day
        if (dayDiff > 2) {
            do {
                markings.push({ xaxis: { from: i, to: i + 24 * 60 * 60 * 1000 }, color: MarkingColor });
                i += 2 * 24 * 60 * 60 * 1000;
            } while (i < axes.xaxis.max);

        }
        else {
            do {
                markings.push({ xaxis: { from: i, to: i + 60 * 60 * 1000 }, color: MarkingColor });
                i += 2 * 60 * 60 * 1000;
            } while (i < axes.xaxis.max);
        }
        return markings;

    }

    function CalcTicks4X(axis) {

        var ticks = [];

        var minDate = new Date(axis.min);

        const dayDiff = (axis.max - axis.min) / 1000 / 60 / 60 / 24;

        console.log('DayDiff ' + dayDiff);

        //if we only few hours then we need markings per hour otherwise per day
        if (dayDiff > 2) {
            minDate.setUTCHours(12);
            minDate.setUTCMinutes(0);
            var i = minDate.getTime();
            do {
                ticks.push([i]);
                i += 24 * 60 * 60 * 1000;
            } while (i < axis.max);
        }
        else {
            minDate.setUTCHours(0);
            minDate.setUTCMinutes(0);
            var i = minDate.getTime();
            do {
                ticks.push([i]);
                i += 6 * 60 * 60 * 1000;
            } while (i < axis.max);
        }
        return ticks;
    }

    vis.binds.weather = {
        version: "2.3.1",
        showVersion: function () {
            if (vis.binds.weather.version) {
                console.log('Version vis-weather: ' + vis.binds.weather.version);
                vis.binds.weather.version = null;
            }
        },
        setup: {
            intervals:
                {
                    '1 second': 1000,
                    '10 seconds': 10000,
                    '30 seconds': 30000,
                    '1 minute': 60000,
                    '2 minutes': 120000,
                    '5 minutes': 300000,
                    '10 minutes': 600000,
                    '30 minutes': 1800000,
                    '1 hour': 3600000,
                    '2 hours': 7200000,
                    '4 hours': 14400000,
                    '8 hours': 28800000,
                    '12 hours': 43200000,
                    '24 hours': 86400000
                },
        },
        tempandrain: {


            //==================================================================================
            //
            // just for test
            // will be commented out later
            test: function (widgetID, view, data, style) {
                console.log("test begins here ");

                var $div = $('#' + widgetID);
                // if nothing found => wait
                if (!$div.length) {
                    return setTimeout(function () {
                        console.log("need to wait...");
                        vis.binds.weather.tempandrain.test(widgetID, view, data, style);
                    }, 100);
                }

                var text = '';
                text += 'OID: ' + data.oid + '</div><br>';
                text += 'OID value: <span class="myset-value">' + vis.states[data.oid + '.val'] + '</span><br>';
                text += 'Color: <span style="color: ' + data.myColor + '">' + data.myColor + '</span><br>';
                text += 'extraAttr: ' + data.extraAttr + '<br>';
                text += 'Browser instance: ' + vis.instance + '<br>';
                text += 'htmlText: <textarea readonly style="width:100%">' + (data.htmlText || '') + '</textarea><br>';

                $('#' + widgetID).html(text);

                // subscribe on updates of value
                if (data.oid) {
                    vis.states.bind(data.oid + '.val', function (e, newVal, oldVal) {
                        $div.find('.template-value').html(newVal);
                    });
                }

            },





            init: function (widgetID, view, data1, style) {
                var $div = $('#' + widgetID);
                console.log("temp and rain init (" + widgetID + ")");
                var data = {};
                for (var s in data1) {
                    if (s[0] !== '_' && data1.hasOwnProperty(s) && typeof data1[s] !== 'object' && typeof data1[s] !== 'function') {
                        data[s] = data1[s];
                    }

                }

                function update() {

                    console.log("ShowChart temp/rain/cloud  (" + widgetID + ")");

                    var $div = $('#' + widgetID);
                    // if nothing found => wait
                    if (!$div.length) {
                        return setTimeout(function () {
                            console.log("need to wait... (" + widgetID + ")");
                            update();
                        }, 100);
                    }

                    console.log("ShowChart temp/rain/cloud begin (" + widgetID + ")");

                    if (!data || !data.instance) {
                        console.log("keine instanz  (" + widgetID + ")");
                        $div.html("<br> <center> <font color='red'> no instance  specified </font> </center></br>");
                    }
                    else if (data.instance.indexOf("daswetter") > -1 && data.oid_date == "") {
                        console.log("no OID's for DasWetter  (" + widgetID + ")");
                        $div.html("<br> <center> <font color='red'> no OID's for DasWetter specified </font> </center></br>");
                    }
                    else {



                        SetMarkingColor(data.markingcolor);

                        var values_rain = [];
                        var values_chancerain = [];
                        var maxY_rain = -99;
                        var minY_rain = 100;
                        var values_temp = [];
                        var maxY_temp = -99;
                        var minY_temp = 100;
                        var values_cloud = [];
                        var maxY_cloud = 100;
                        var minY_cloud = 0;
                        var cnt = 0;


                        var max_cnt = 0;
                        var day = 0;
                        var month = 0;
                        var year = 0;
                        var hour = 0;
                        var minute = 0;

                        var nTimeDiff = -1;
                        var oldHour = -1;

                        if (data.instance.indexOf("daswetter") > -1) {

                            //get first date only for DasWetter.com
                            //20180825
                            var oid_first_date = data.oid_date;
                            var sDate = vis.states[oid_first_date + '.val'];
                            var day = parseInt(sDate.substring(6, 8), 10);
                            var month = parseInt(sDate.substring(4, 6), 10);
                            var year = parseInt(sDate.substring(0, 4), 10);
                            //console.log("got " + sDate + " from " + oid_first_date);
                            console.log("got first date " + sDate + " = " + day + "." + month + "." + year);
                            month--;

                            max_cnt = 40;
                            data.chancerainvisible = false; // value not available!!

                        }
                        else if (data.instance.indexOf("weatherunderground") > -1) {
                            max_cnt = 36;
                        }

                        //console.log("date is " + day +"."+month+"."+year);
                        var lastHour = -1;
                        for (var d = 0; d < max_cnt; d++) {

                            //get rain values
                            var oid_rain = data['oid_rain' + d];
                            var val_rain = parseFloat(vis.states[oid_rain + '.val']);
                            //console.log("got " + val_rain + " from " + oid_rain);
                            if (val_rain > maxY_rain) maxY_rain = val_rain;
                            if (val_rain < minY_rain) minY_rain = val_rain;
                            var oid_chancerain = data['oid_chancerain' + d];
                            var val_chancerain = parseInt(vis.states[oid_chancerain + '.val'], 10);
                            //console.log("got " + val_chancerain + " from " + oid_chancerain);


                            //get temperature values
                            var oid_temp = data['oid_temp' + d];
                            var val_temp = parseInt(vis.states[oid_temp + '.val'], 10);
                            //console.log("got " + val_temp + " from " + oid_temp);
                            if (val_temp > maxY_temp) maxY_temp = val_temp;
                            if (val_temp < minY_temp) minY_temp = val_temp;

                            //get cloud values
                            var oid_cloud = data['oid_cloud' + d];
                            var val = parseInt(vis.states[oid_cloud + '.val'], 10);
                            //console.log("got " + val + " from " + oid_cloud);
                            var val_cloud = 0;
                            if (data.sunorcloud == "sun") { //invert value
                                val_cloud = 100 - val;
                            }
                            else {
                                val_cloud = val;
                            }

                            // get time
                            var oid = data['oid_hour' + d];
                            //console.log("check " + oid);
                            if (oid.length < 3) {
                                //stop loop here
                                console.log("less then " + max_cnt + " oid (" + d + ") found");
                                d = max_cnt;
                                break;
                            }
                            var sTime = vis.states[oid + '.val'];
                            //console.log("got " + sTime + " from " + oid);
                            //console.log("got " + sTime );

                            var bDateNotValid = false;
                            var month1 = month + 1;
                            //console.log("### date " + day + "." + month1 + "." + year);

                            var oDate;
                            if (data.instance.indexOf("daswetter") > -1) {

                                hour = parseInt(sTime.substring(0, 2), 10);
                                minute = parseInt(sTime.substring(3, 5), 10);

                                oDate = new Date(year, month, day, hour, minute, 0, 0);

                                //console.log("### check next day " + hour + " ? " + lastHour + " at " + oDate.toLocaleString());

                                //check next day
                                if (hour < lastHour) {
                                    oDate.setDate(oDate.getDate() + 1);
                                    day = oDate.getDate();
                                    month = oDate.getMonth();
                                    year = oDate.getFullYear();

                                    //console.log("### next day found " + oDate.toLocaleString());
                                }
                                lastHour = hour;
                            }
                            else if (data.instance.indexOf("weatherunderground") > -1) {





                                if (typeof sTime == 'undefined') {
                                    bDateNotValid = true;
                                }
                                else {



                                    //check which version??
                                    //V1.x: 05:00 PM CEST am 18. August 2018
                                    //V2.x: 8/18/2018, 5:00:00 PM
                                    //      oder 2018 - 8 - 19 12: 00: 00
                                    var oTemp = sTime.split(' ');
                                    var wuversion = 0;
                                    if (oTemp[1] == "PM" || oTemp[1] == "AM") {
                                        wuversion = 1;
                                        //console.log("+++ old version +++");
                                    }
                                    else {
                                        wuversion = 2;
                                        //console.log("+++ new version +++");
                                    }

                                    if (wuversion == 2) {

                                        //acc. https://stackoverflow.com/questions/4310953/invalid-date-in-safari#
                                        //safari doesnt support 2018-8-26
                                        //it supports:
                                        //MM - dd - yyyy
                                        //yyyy / MM / dd
                                        //MM / dd / yyyy
                                        //MMMM dd, yyyy
                                        //MMM dd, yyyy
                                        //so we just replace '-' by '/'

                                        //test only:
                                        //sTime = "2018-8-26";

                                        //in WU wird ToLocalstring verwendet
                                        var oDateWU = new Date(sTime.replace(/-/g, "/"));
                                        hour = oDateWU.getHours();
                                        minute = oDateWU.getMinutes();
                                        year = oDateWU.getFullYear();
                                        month = oDateWU.getMonth();
                                        day = oDateWU.getDate();
                                        //console.log("--------" + sTime + " = " + oDateWU.toLocaleString());
                                    }
                                    else {
                                        // WU V1.0

                                        //04:00 PM CEST am 14. Mai 2017

                                        var oTemp1 = oTemp[0].split(':');

                                        hour = parseInt(oTemp1[0], 10);
                                        if (oTemp[1] == "PM" && hour != 12) {
                                            hour += 12; //PM
                                        }
                                        if (oTemp[1] == "AM" && hour == 12) {
                                            hour = 0; //AM
                                        }
                                        //12 PM ist 12 Mittags
                                        //12 AM ist 0 Nachts

                                        minute = parseInt(oTemp1[1], 10);
                                        year = parseInt(oTemp[6], 10);

                                        switch (oTemp[5]) {
                                            case "Januar": month = 0; break;
                                            case "Februar": month = 1; break;
                                            case "März": month = 2; break;
                                            case "April": month = 3; break;
                                            case "Mai": month = 4; break;
                                            case "Juni": month = 5; break;
                                            case "Juli": month = 6; break;
                                            case "August": month = 7; break;
                                            case "September": month = 8; break;
                                            case "Oktober": month = 9; break;
                                            case "November": month = 10; break;
                                            case "Dezember": month = 11; break;
                                        }


                                        day = parseInt(oTemp[4], 10);
                                    }
                                    //console.log("--------" + day + "." + month + 1 + "." + year + " " + hour + ":" + minute);
                                    oDate = new Date(year, month, day, hour, minute, 0, 0);
                                }
                            }
                            //console.log("-#--#---" + day + "." + month + "." + year + " " + hour + ":" + minute);

                            if (oldHour > 0) {
                                nTimeDiff = hour - oldHour;
                            }
                            //console.log("++++ timediff " + nTimeDiff);
                            oldHour = hour;

                            //console.log(date+" "+ val_rain + " " + val_temp + " " + val_cloud);

                            if (!bDateNotValid) {
                                //need time in UTC
                                var date = oDate.getTime();
                                //console.log(date);
                                values_rain.push([date, val_rain]);
                                values_temp.push([date, val_temp]);
                                values_cloud.push([date, val_cloud]);
                                values_chancerain.push([date, val_chancerain]);
                            }
                        }



                        //maxY += 0.1 * maxY;
                        //minY -= 0.1 * minY;

                        maxY_temp = Math.ceil((maxY_temp + 1) / 10) * 10;
                        if (minY_temp > 0) {
                            minY_temp = 0;
                        }
                        else {
                            var temp1 = Math.abs(minY_temp);

                            minY_temp = Math.ceil((temp1 + 1) / 10) * 10;
                            minY_temp = -1.0 * minY_temp;
                        }



                        maxY_rain = Math.ceil((maxY_rain + 1) / 10) * 10;
                        if (maxY_rain < 10) maxY_rain = 10;

                        //console.log("start " + maxY_rain + " / " + minY_rain + " " + maxY_temp + " / " + minY_temp);


                        var barwidth = 0;
                        if (data.instance.indexOf("daswetter") > -1) {

                            if (nTimeDiff > 0) {
                                barwidth = 1000 * 60 * 60 * nTimeDiff;
                            }
                            else {
                                barwidth = 1000 * 60 * 60 * 1; //1h
                            }
                        }
                        else if (data.instance.indexOf("weatherunderground") > -1) {
                            barwidth = 1000 * 60 * 60 * 0.5; //0.5h
                        }
                        //console.log("barwidth = " + barwidth); // in ms


                        console.log("start plot (" + widgetID + ")");

                        $.plot($div,
                            [{
                                data: data.chancerainvisible ? values_chancerain : {},
                                color: data.chanceraincolor,
                                xaxis: 1,
                                yaxis: 4,
                                lines: { show: false },
                                bars:
                                    {
                                        show: true,
                                        barWidth: barwidth,
                                        align: "center"
                                    }
                            },


                            {
                                data: data.tempvisible ? values_temp : {},
                                color: data.tempcolor,
                                xaxis: 1,
                                yaxis: 1,
                                lines: { show: data.tempchartType == "line" ? true : false, fill: false },
                                bars:
                                    {
                                        show: data.tempchartType == "bar" ? true : false,
                                        barWidth: barwidth,
                                        align: "center"
                                    }
                            },
                            {
                                data: data.rainvisible ? values_rain : {},
                                color: data.raincolor,
                                xaxis: 1,
                                yaxis: 2,
                                lines: { show: data.rainchartType == "line" ? true : false, fill: false },
                                bars:
                                    {
                                        show: data.rainchartType == "bar" ? true : false,
                                        barWidth: barwidth,
                                        align: "center"
                                    }
                            },
                            {
                                data: data.cloudsvisible ? values_cloud : {},
                                color: data.cloudcolor,
                                xaxis: 1,
                                yaxis: 3,
                                lines: { show: data.cloudschartType == "line" ? true : false, fill: false },
                                bars:
                                    {
                                        show: data.cloudschartType == "bar" ? true : false,
                                        barWidth: barwidth,
                                        align: "center"
                                    }
                            }

                            ],
                            {

                                xaxes:
                                    [{
                                        show: data.withxaxix,
                                        mode: "time",
                                        tickLength: 5,
                                        //ticks: data.ticksonxaxix > 0 ? parseInt(data.ticksonxaxix, 10) : 5,
                                        ticks: CalcTicks4X,
                                        timeformat: data.xDateFormat,
                                        monthNames: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
                                        color: data.tickscolor,
                                        font: {
                                            color: data.axislabelcolor
                                        }
                                    }],

                                yaxes:


                                    //temp y-axis #1
                                    [{
                                        show: (data.tempvisible && data.yTempVisible),
                                        max: data.maxY_temp != 0 ? parseInt(data.maxY_temp, 10) : maxY_temp, //0 = default = auto determine max/min value
                                        min: data.minY_temp != 0 ? parseInt(data.minY_temp, 10) : minY_temp,
                                        alignTicksWithAxis: 1,
                                        position: 'left',
                                        ticks: 3,
                                        color: data.tickscolor,
                                        font: {
                                            color: data.tempcolor,
                                        },
                                        tickFormatter: degreeFormatter
                                    },

                                    //rain visible y-axis #2
                                    {
                                        show: (data.rainvisible && data.yRainVisible),
                                        max: maxY_rain,
                                        min: 0,
                                        alignTicksWithAxis: 2,
                                        position: 'right',
                                        ticks: 3,
                                        color: data.tickscolor,
                                        font: {
                                            color: data.raincolor,
                                        },
                                        tickFormatter: mmFormatter
                                    },

                                    //sun-cloud y-axis
                                    {
                                        show: (data.cloudsvisible && data.yCloudVisible),
                                        max: maxY_cloud,
                                        min: minY_cloud,
                                        alignTicksWithAxis: 3,
                                        position: 'left',
                                        ticks: 3,
                                        color: data.tickscolor,
                                        font: {
                                            color: data.cloudcolor
                                        },
                                        tickFormatter: percentageFormatter
                                    },

                                    //chance rain y-axis  #4
                                    {
                                        show: (data.chancerainvisible && data.yChanceRainVisible),  //much better visible without
                                        max: 100,
                                        min: 0,
                                        alignTicksWithAxis: 4,
                                        position: 'right',
                                        ticks: 3,
                                        color: data.tickscolor,
                                        font: {
                                            color: data.raincolor
                                        },
                                        tickFormatter: percentageFormatter
                                    }],
                                grid:
                                    {
                                        markings: data.withmarking ? GridMarkings : null,

                                        backgroundColor: data.nobgcolor ? null : { colors: ["#fff", "#eee"] },
                                        borderWidth: {
                                            top: data.withborder ? 1 : 0,
                                            right: data.withborder ? 1 : 0,
                                            bottom: data.withborder ? 2 : 0,
                                            left: data.withborder ? 2 : 0
                                        },

                                    }
                            }
                        );



                    }

                };



                if (data.instance) {
                    //Umschalten wu / daswetter und auf oid zugreifen
                    var max_cnt = 0;
                    if (data.instance.indexOf("daswetter") > -1) {
                        var oid_first_date = data.oid_date;
                        //console.log("bind " + oid_first_date);
                        vis.states.bind(oid_first_date + '.val', function () {
                            update();
                        });
                        max_cnt = 40;
                    }

                    else if (data.instance.indexOf("weatherunderground") > -1) {
                        max_cnt = 36;
                    }

                    else {
                        console.log("no wether instance set in init " + data.instance);
                    }

                    if (data.instance.indexOf("weatherunderground") > -1) {
                        for (var i = 0; i < max_cnt; i++) {
                            //get chance rain oid
                            var oid_chancerain = data['oid_chancerain' + i];
                            //console.log("bind " + oid_chancerain);
                            vis.states.bind(oid_chancerain + '.val', function () {
                                update();
                            });
                        }

                    }

                    //gilt für beide nur mit unterschiedlichen grenzen
                    for (var i = 0; i < max_cnt; i++) {
                        //get rain oid
                        var oid_rain = data['oid_rain' + i];
                        //console.log("bind " + oid_rain);
                        vis.states.bind(oid_rain + '.val', function () {
                            update();
                        });
                        //get temperature oid
                        var oid_temp = data['oid_temp' + i];
                        //console.log("bind " + oid_temp);
                        vis.states.bind(oid_temp + '.val', function () {
                            update();
                        });
                        //get cloud oid
                        var oid_cloud = data['oid_cloud' + i];
                        //console.log("bind " + oid_cloud);
                        vis.states.bind(oid_cloud + '.val', function () {
                            update();
                        });
                        // get time oid
                        var oid_hour = data['oid_hour' + i];
                        //console.log("bind " + oid_hour);
                        vis.states.bind(oid_hour + '.val', function () {
                            update();
                        });
                    }

                    // update every x seconds
                    if (!vis.editMode) {
                        $div.data('timer', setInterval(function () {
                            update();
                        }, parseInt(vis.binds.weather.setup.intervals[data.time_interval] / (parseInt(data.points, 10) || 10), 10)));
                    }
                }
                else {
                    console.log("instance not set ");
                }
                update();
                if (vis.editMode) {
                    console.log("flot version " + $.plot.version + " for weather");
                }
            }
        },
    };

    if (vis.editMode) {
        vis.binds.weather.onInstanceChanged = function (widgetID, view, newId, fields) {
            //we use the same callback for different changes;
            //so we need to check what have been changed...
            console.log('--------- : ' + widgetID + ' - ' + view + ' - ' + newId + ' - ' + fields);
            var instanceID = "";
            var datastructurename = "";
            if (fields == "instance") {
                instanceID = newId;
                datastructurename = vis.widgets[widgetID].data.datastructure;
                console.log('instance changed to ' + newId + ' old structure = ' + datastructurename);
            }

            else if (fields == "datastructure") {
                datastructurename = newId;
                instanceID = vis.widgets[widgetID].data.instance;
                console.log('datastructure changed to ' + newId + ' old instance = ' + instanceID);
            }



            //delete all
            vis.views[view].widgets[widgetID].data.oid_date = "";
            vis.widgets[widgetID].data.oid_date = "";

            for (var h = 0; h < 40; h++) {
                vis.views[view].widgets[widgetID].data['oid_rain' + h] = "";
                vis.widgets[widgetID].data['oid_rain' + h] = "";
                vis.views[view].widgets[widgetID].data['oid_chancerain' + h] = "";
                vis.widgets[widgetID].data['oid_chancerain' + h] = "";
                vis.views[view].widgets[widgetID].data['oid_temp' + h] = "";
                vis.widgets[widgetID].data['oid_temp' + h] = "";
                vis.views[view].widgets[widgetID].data['oid_cloud' + h] = "";
                vis.widgets[widgetID].data['oid_cloud' + h] = "";
                vis.views[view].widgets[widgetID].data['oid_hour' + h] = "";
                vis.widgets[widgetID].data['oid_hour' + h] = "";
            }

            //wu oder DasWetter (umschaltbar)

            var changed = [];
            var oid_rain = "";
            var oid_chancerain = "";
            var oid_temp = "";
            var oid_cloud = "";
            var oid_hour = "";

            if (instanceID.indexOf("daswetter") > -1) {
                var daswetterversion = 0;
                //with 1.x: daswetter.0.NextDaysDetailed.0d.date 20180524
                //with 2.x: daswetter.0.NextDaysDetailed.Location_1.Day_1.day_value 20180524
                var oid_first_date = "";
                if (vis.views[view].widgets[widgetID].data.datastructure == "NextDaysDetailed") {
                    oid_first_date = instanceID + ".NextDaysDetailed.Location_1.Day_1.day_value";
                }

                else if (vis.views[view].widgets[widgetID].data.datastructure == "NextHours") {
                    oid_first_date = instanceID + ".NextHours.Location_1.Day_1.day_value";
                }

                else if (vis.views[view].widgets[widgetID].data.datastructure == "NextHours2") {
                    oid_first_date = instanceID + ".NextHours2.Location_1.Day_1.date";
                }


                if (vis.objects[oid_first_date]) {
                    daswetterversion = 2;
                    console.log("using new data structure with DasWetter");
                }

                else {
                    oid_first_date = instanceID + ".NextDaysDetailed.0d.date";
                    if (vis.objects[oid_first_date]) {
                        daswetterversion = 1;
                        console.log("using old data structure with DasWetter");
                    }

                }

                //which datastructure
                console.log("datastructure is " + vis.views[view].widgets[widgetID].data.datastructure);


                if (vis.objects[oid_first_date]) {
                    //console.log(oid_first_date + " updated ");
                    vis.views[view].widgets[widgetID].data.oid_date = oid_first_date;
                    vis.widgets[widgetID].data.oid_date = oid_first_date;
                }

                var cnt = 0;
                var max_days = 5;
                var max_periods = 8;


                //we only have 40 OID'S!!!
                if (daswetterversion == 2) {
                    if (vis.views[view].widgets[widgetID].data.datastructure == "NextDaysDetailed") {
                        max_days = 5;
                        max_periods = 8;
                    }

                    else if (vis.views[view].widgets[widgetID].data.datastructure == "NextHours") {
                        max_days = 5;
                        max_periods = 24;
                    }

                    else if (vis.views[view].widgets[widgetID].data.datastructure == "NextHours2") {
                        max_days = 5;
                        max_periods = 8;
                    }

                }


                for (var d = 0; d < max_days; d++) {
                    for (var p = 0; p < max_periods; p++) {
                        //get rain oid

                        if (daswetterversion == 1) {
                            oid_rain = instanceID + ".NextDaysDetailed." + d + "d." + p + "h.Rain";
                            //get temperature oid
                            oid_temp = instanceID + ".NextDaysDetailed." + d + "d." + p + "h.Temperature";
                            //get cloud oid
                            oid_cloud = instanceID + ".NextDaysDetailed." + d + "d." + p + "h.Clouds";
                            // get time oid
                            oid_hour = instanceID + ".NextDaysDetailed." + d + "d." + p + "h.hour";
                        }
                        else if (daswetterversion == 2) {
                            //daswetter.0.NextDaysDetailed.Location_1.Day_1.Hour_1.rain.value
                            var dd = d + 1;
                            var pp = p + 1;
                            //NextDaysDetailed,NextHours,NextHours2
                            if (datastructurename == "NextDaysDetailed") {
                                //daswetter.0.NextDaysDetailed.Location_1.Day_1.Hour_1.rain_value
                                oid_rain = instanceID + ".NextDaysDetailed.Location_1.Day_" + dd + ".Hour_" + pp + ".rain_value";
                                //get temperature oid
                                oid_temp = instanceID + ".NextDaysDetailed.Location_1.Day_" + dd + ".Hour_" + pp + ".temp_value";
                                //get cloud oid
                                oid_cloud = instanceID + ".NextDaysDetailed.Location_1.Day_" + dd + ".Hour_" + pp + ".clouds_value";
                                // get time oid
                                oid_hour = instanceID + ".NextDaysDetailed.Location_1.Day_" + dd + ".Hour_" + pp + ".hour_value";
                            }

                            else if (datastructurename == "NextHours") {
                                //daswetter.0.NextHours.Location_1.Day_1.Hour_1.rain_value
                                oid_rain = instanceID + ".NextHours.Location_1.Day_" + dd + ".Hour_" + pp + ".rain_value";
                                //get temperature oid //daswetter.0.NextHours.Location_1.Day_1.Hour_1.temp_value
                                oid_temp = instanceID + ".NextHours.Location_1.Day_" + dd + ".Hour_" + pp + ".temp_value";
                                //get cloud oid //daswetter.0.NextHours.Location_1.Day_1.Hour_1.clouds_value
                                oid_cloud = instanceID + ".NextHours.Location_1.Day_" + dd + ".Hour_" + pp + ".clouds_value";
                                // get time oid //daswetter.0.NextHours.Location_1.Day_1.Hour_1.hour_value
                                oid_hour = instanceID + ".NextHours.Location_1.Day_" + dd + ".Hour_" + pp + ".hour_value";
                            }

                            else if (datastructurename == "NextHours2") {
                                //daswetter.0.NextHours2.Location_1.Day_1.Hour_1.rain
                                oid_rain = instanceID + ".NextHours2.Location_1.Day_" + dd + ".Hour_" + pp + ".rain";
                                //get temperature oid //daswetter.0.NextHours2.Location_1.Day_1.Hour_1.temp
                                oid_temp = instanceID + ".NextHours2.Location_1.Day_" + dd + ".Hour_" + pp + ".temp";
                                //get cloud oid //daswetter.0.NextHours2.Location_1.Day_1.Hour_1.clouds
                                oid_cloud = instanceID + ".NextHours2.Location_1.Day_" + dd + ".Hour_" + pp + ".clouds";
                                // get time oid //daswetter.0.NextHours2.Location_1.Day_1.Hour_1.hour
                                oid_hour = instanceID + ".NextHours2.Location_1.Day_" + dd + ".Hour_" + pp + ".hour";
                            }

                        }

                        else {
                            console.log("could not define which version to use with DasWetter");
                        }

                        if (vis.objects[oid_rain]) {
                            //console.log(oid_rain + " updated ");
                            vis.views[view].widgets[widgetID].data['oid_rain' + cnt] = oid_rain;
                            vis.widgets[widgetID].data['oid_rain' + cnt] = oid_rain;
                        }

                        if (vis.objects[oid_temp]) {
                            //console.log(oid_temp + " updated ");
                            vis.views[view].widgets[widgetID].data['oid_temp' + cnt] = oid_temp;
                            vis.widgets[widgetID].data['oid_temp' + cnt] = oid_temp;
                        }

                        if (vis.objects[oid_cloud]) {
                            //console.log(oid_cloud + " updated ");
                            vis.views[view].widgets[widgetID].data['oid_cloud' + cnt] = oid_cloud;
                            vis.widgets[widgetID].data['oid_cloud' + cnt] = oid_cloud;
                        }

                        if (vis.objects[oid_hour]) {
                            //console.log(oid_hour + " updated ");
                            vis.views[view].widgets[widgetID].data['oid_hour' + cnt] = oid_hour;
                            vis.widgets[widgetID].data['oid_hour' + cnt] = oid_hour;
                        }

                        cnt++;
                        if (cnt >= 40) {
                            console.log("OID limit reached");
                            break;
                        }

                    }
                }
            }

            else if (instanceID.indexOf("weatherunderground") > -1) {
                vis.views[view].widgets[widgetID].data.datastructure = "";
                vis.widgets[widgetID].data.datastructure = "";
                var wuversion = 0;
                //weatherunderground.0.forecastHourly.0h.time
                var oid_version_check = instanceID + ".forecastHourly.0h.time";
                if (vis.objects[oid_version_check]) {
                    wuversion = 2;
                    console.log("using new data structure with WU");
                }

                else {
                    //weatherunderground.0.forecast.0h.time
                    oid_version_check = instanceID + ".forecast.0h.time";
                    if (vis.objects[oid_version_check]) {
                        wuversion = 1;
                        console.log("using old data structure with WU");
                    }

                }



                for (var h = 0; h < 36; h++) {
                    if (wuversion == 1) {
                        //get rain oid weatherunderground.0.forecast.0h.qpf
                        oid_rain = instanceID + ".forecast." + h + "h.qpf";
                        //get rain oid weatherunderground.0.forecast.0h.qpf
                        oid_chancerain = instanceID + ".forecast." + h + "h.pop";
                        //get temperature oid weatherunderground.0.forecast.0h.temp
                        oid_temp = instanceID + ".forecast." + h + "h.temp";
                        //get cloud oid weatherunderground.0.forecast.0h.sky
                        oid_cloud = instanceID + ".forecast." + h + "h.sky";
                        // get time oid
                        oid_hour = instanceID + ".forecast." + h + "h.time";
                    }

                    else if (wuversion == 2) {
                        //get rain oid weatherunderground.0.forecastHourly.0h.precipitation
                        oid_rain = instanceID + ".forecastHourly." + h + "h.precipitation";
                        //get rain oid weatherunderground.0.forecastHourly.0h.precipitationChance
                        oid_chancerain = instanceID + ".forecastHourly." + h + "h.precipitationChance";
                        //get temperature oid weatherunderground.0.forecastHourly.0h.temp
                        oid_temp = instanceID + ".forecastHourly." + h + "h.temp";
                        //get cloud oid weatherunderground.0.forecastHourly.0h.sky
                        oid_cloud = instanceID + ".forecastHourly." + h + "h.sky";
                        // get time oid weatherunderground.0.forecastHourly.0h.time
                        oid_hour = instanceID + ".forecastHourly." + h + "h.time";
                    }

                    else {
                        console.log("could not define which version to use with WU");
                    }

                    if (vis.objects[oid_rain]) {
                        //console.log(oid_rain + " updated ");
                        vis.views[view].widgets[widgetID].data['oid_rain' + h] = oid_rain;
                        vis.widgets[widgetID].data['oid_rain' + h] = oid_rain;
                    }

                    else {
                        //console.log("wrong version of weatherunderground? >1.0.5?");
                    }

                    if (vis.objects[oid_chancerain]) {
                        //console.log(oid_chancerain + " updated ");
                        vis.views[view].widgets[widgetID].data['oid_chancerain' + h] = oid_chancerain;
                        vis.widgets[widgetID].data['oid_chancerain' + h] = oid_rain;
                    }

                    if (vis.objects[oid_temp]) {
                        //console.log(oid_temp + " updated ");
                        vis.views[view].widgets[widgetID].data['oid_temp' + h] = oid_temp;
                        vis.widgets[widgetID].data['oid_temp' + h] = oid_temp;
                    }

                    if (vis.objects[oid_cloud]) {
                        //console.log(oid_cloud + " updated ");
                        vis.views[view].widgets[widgetID].data['oid_cloud' + h] = oid_cloud;
                        vis.widgets[widgetID].data['oid_cloud' + h] = oid_cloud;
                    }

                    if (vis.objects[oid_hour]) {
                        //console.log(oid_hour + " updated ");
                        vis.views[view].widgets[widgetID].data['oid_hour' + h] = oid_hour;
                        vis.widgets[widgetID].data['oid_hour' + h] = oid_hour;
                    }

                }
            }

            else {
                //ja was nun? do nothing
                console.log(" no weather instance set ");
            }

            return changed;
        }
    }

    vis.binds.weather.showVersion();

</script>



<script id="tplWeatherShowInstance"
        type="text/ejs"
        class="vis-tpl"
        data-vis-set="weather"
        data-vis-name="Weather"
        data-vis-beta="false"
        data-vis-type="weather"
        data-vis-update-style="true"
        data-vis-prev='<img src="widgets/weather/img/Prev_tplWeather.png"></img>'
        data-vis-attrs="instance/weather/onInstanceChanged;"
        data-vis-attrs0="time_interval[30 minutes]/select,1 second,10 seconds,30 seconds,1 minute,2 minutes,5 minutes,10 minutes,30 minutes,1 hour,2 hours,4 hours,8 hours,12 hours,24 hours;"
        data-vis-attrs1="datastructure[NextDaysDetailed]/select,NextDaysDetailed,NextHours,NextHours2/onInstanceChanged;"
        data-vis-attrs2="withxaxix[true]/checkbox;axislabelcolor[#ffffff]/color;tickscolor[#ffffff]/color;withmarking[true]/checkbox;markingcolor[#eaebe5]/color;xDateFormat[%d.%b %H:%M];withborder[true]/checkbox;nobgcolor[true]/checkbox;"
        data-vis-attrs3="group.rain;rainvisible[true]/checkbox;rainchartType[bar]/select,line,bar;raincolor[#1d0ed8]/color;chancerainvisible[true]/checkbox;chanceraincolor[#877efc]/color;yRainVisible[true]/checkbox;yChanceRainVisible[true]/checkbox;"
        data-vis-attrs4="group.temperature;tempvisible[true]/checkbox;tempchartType[line]/select,line,bar;tempcolor[#00b3ac]/color;maxY_temp[0];minY_temp[0];yTempVisible[true]/checkbox;"
        data-vis-attrs5="group.clouds;cloudsvisible/checkbox;cloudschartType[bar]/select,line,bar; sunorcloud[sun]/select,sun,clouds;cloudcolor[#f6ef3c]/color;yCloudVisible[true]/checkbox;"
        data-vis-attrs6="group.oids;oid_rain(0-39)/id;oid_chancerain(0-39)/id;oid_temp(0-39)/id;oid_cloud(0-39)/id;oid_hour(0-39)/id;"
        data-vis-attrs7="oid_date/id;">


    <div class="vis-widget <%== this.data.attr('class') %>" style="overflow: hidden; width: 210px; height: 170px; " id="<%= this.data.attr('wid') %>">
        <div class="vis-weather-widget-body">
            <% vis.binds.weather.tempandrain.init(this.data.wid, this.view, this.data, this.style); %>
        </div>

    </div>

</script>

<!-- just for testing
<script id="tplWeatherTest"
        type="text/ejs"
        class="vis-tpl"
        data-vis-prev='<img src="widgets/weather/img/Prev_tplWeather.png"></img>'
        data-vis-attrs="oid/id;myColor/color;htmlText/text;"
        data-vis-set="weather"
        data-vis-type="weather"
        data-vis-name="WeatherTest"
        data-vis-beta="true">
    <div class="vis-widget <%== this.data.attr('class') %>" style="overflow:visible; width: 230px; height: 210px" id="<%= this.data.attr('wid') %>">
        <%
        vis.binds.weather.tempandrain.test(this.data.wid, this.view, this.data, this.style);
        %>
    </div>
</script>
    -->
